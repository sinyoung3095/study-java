메소드
		이름뒤에 소괄호
		단, 키워드 뒤에 소괄호는 메소드가 아니다.
		저장공간이다.
		
		f	(x)	=	2x + 1
	   메소드   매개		리턴값
	   이름      변수

메소드 선언
		
		(1)리턴타입  (2)메소드명  (자료형 (3)매개변수명,...)  { 

				(4)실행할 문장

				(5)return 리턴 값;
		}

		(1) 리턴값이 있다면 리턴값의 자료형을 작성하고, 리턴값이 없다면 void를 작성한다.
		(2) 동사로 작성한다.
		(3) 외부에서 전달받을 값이 있다면, 자료형과 순서에 맞게 선언해준다.
		    생략하면 외부에서 값을 전달 받을 수 없게 된다.
		(4) 생략이 가능하다. 메소드의 기능을 구현하는 로직을 작성하게 된다.
		(5) 생략이 가능하다. 리턴값이 있다면, 사용한 부분 통채로를 리턴값으로 봐야한다.

메소드 선언 순서
	
		문제) 두 정수의 덧셈 메소드 선언

		1. 메소드 이름을 생각한다.
				add(){}

		2. 매개변수를 생각한다.
				add(int number1, int number2){}

		3. 실행할 문장을 작성한다.
				add(int number1, int number2){
					int result = number1 + number2 
				}

		4. 리턴값을 작성한다.
				add(int number1, int number2){
					int result = number1 + number2 
					return result;
				}


		5. 리턴타입을 결정한다.
				  int add(int number1, int number2){
        				int result = number1 + number2;
     					return result;
   				   }


메소드 주의사항

		1. 메소드를 선언할 때 {}가 있으며, 반드시 메소드 밖에서 선언한다.
		2. 메소드를 사용할 때 {}가 없으며, 반드시 메소드 안에서 선언한다.

메소드를 사용하는 이유
		
		1. 재사용(특정성을 부여해서는 안된다.)
		2. 소스코드 간결화

다형성(Polymorphism)

		1. 오버로딩(Overloading)
			매개변수의 개수 또는 자료형이 다르면 동일한 이름의 메소드로 선언할 수 있다.
		2. 오버라이딩(Overriding, 무시하기, 재정의)
			부모 필드에서 선언한 메소드를 자식 필드에서 수정하고자 할 때 재정의 한다.
			같은 이름의 메소드로 선언하면, 자식 객체로 접근했을 때 가까운 곳에서 찾기 때문에
			자식 필드(this)에서 재정의된 메소드가 사용된다.
			만약 재정의된 메소드 안에서 부모의 기능을 그대로 사용하고 싶다면,
			super로 접근해서 사용할 수 있다.


































